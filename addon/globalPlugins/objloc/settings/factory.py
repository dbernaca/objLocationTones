from .exceptions import SettingsError
from .objects import Attribute
from inspect  import currentframe as getframe

def Settable (value, nickname=None, *args, **kwargs):
    """
    This function is meant to be called within your instance's method or a class
    when defining an attribute that will later be managed by the Settings() object.
    E.g.:
    >>> class a:
    >>>     b = Settable(1)
    >>>     def __init__ (self):
    >>>         self.something = Settable(5)
    >>>
    After you use one of the Settings()'s object methods on your instance, the attribute will be recognized as settable, and replaced
    with your defined value, or with the value loaded from the settings file.
    The function expects to be called from a method or directly from the class.
    Within methods, the "self", or, in case of classmethods, "cls" variables are expected,
    so keep the conventional argument names or Settable() will not work.
    Also, the class level Settable()s will later be treated as instance attributes,
    and class level values will not be affected.
    That is, the class level attribute declared Settable() object, can stay Attribute() object forever.

    Important keyword arguments:
    ----------------------------
    skip:    bool() --> If True the value will not be affected by the settings file. Defaults to False
    save:    bool() --> If False the value will not be saved to the settings file. Defaults to True
    show:    bool() --> If False the GUI control will not be created and shown in settings panel. Defaults to True
    label:    str() --> Label in settings panel. If not provided the GUI control will not be created and presented in settings panel
    ordinal:  int() --> An ordinal number that will be used to manage order of controls in the settings panel. If not present an order of creation will be followed.

    What kind of control is created in the settings panel depends on type of the value.

    bool() will create a wx.CheckBox() and the current value will determine whether it is checked or not immediately.

    int() and float() types result in wx.TextCtrl() that cannot receive any other input but proper format for int or float respectively.
    The current value will be shown in the control.

    If there are min and max arguments present a wx.Slider will be returned instead
    and its value set to the variables current value.
    min and max arguments must be int()s as required by wx.Slider(), but if value type is float()
    then the ratio argument must be given, which will be used to convert the slider value to float and vice-versa
    via multiplication and division as needed.

    A str() will naturally result in wx.TextCtrl() with the value set to the current value.

    A special case when a value type is int() or str() and choices argument is present then
    the control in settings panel will be wx.Choice() or wx.ListBox().
    When choices argument type is tuple() the result is wx.Choice(), when list(), the result is wx.ListBox().
    choices is a sequence of strings that represents items in the control.
    If value type is int() the selection index will be stored into the variable, if str()
    the label of the item will be stored instead.
    When the wx.Choice() or wx.ListBox() is created, the variable's current value will be immediately selected.

    Controls can be interacted with in real-time by using
    following optional arguments:
    -----------------------------------------------------
    reactor   --> A callback that will react to a change of the dynamic control
                  One argument will be passed to the callback function, which is the wx.Event() generated by the control
    filter    --> A callback that will be called when getting a value from the control
                  A return value of filter() will be the actual value set to the variable.
    adjuster  --> A callback that will be called when setting a value to the control
                  A return value of adjuster() will be the actual value set to the control.
    validator --> Needs to return a bool() that indicates whether the value from the control is valid or not.
                  It is used before saving the settings to notify user about wrong input if necessary.
    filter(), adjuster() and validator() receive two arguments:
    first argument is the Attribute() instance for this particular variable returned from settings manager instance,
    the second argument is the value found in the GUI control.
    """
    f = getframe().f_back
    if "__module__" in f.f_locals and "__qualname__" in f.f_locals:
        # Called within a class body
        obj = Ellipsis # Name and instance autodetect via descriptor protocol
    else:
        obj = f.f_locals.get("self", f.f_locals.get("cls"))
    args = dict(enumerate(args))
    args.update(kwargs)
    if obj is not None:
        return Attribute(obj, Ellipsis, type(value), value, nickname, args)
    raise SettingsError("Settable() must be called from within a class or a method")

def Activator (label, callback, *args, **kwargs):
    """
    This function is meant to be called within your instance's method or class.
    It defines a button for the settings panel that will call a function given by the callback argument when pressed.
    The Activator() returns a special Attribute() object which must be assigned to an attribute
    because the settings loading process will process it later, so it must be detectable.
    The attribute's value, afterwards will be Ellipsis, as it
    essentially does nothing except creating a GUI  button and will not be saved to a settings file of course.
    The function expects to be called from a method or directly from the class.
    Within methods, the "self", or, in case of classmethods, "cls" variables are expected,
    so keep the conventional argument names or Activator() will not work.
    Also, the class level Activator() attributes will later be treated as instance attributes,
    and class level values will not be affected.
    That is, the class level attribute declared Activator(), can stay Attribute() object forever.
    """
    kwargs["skip"] = True
    kwargs["save"] = False
    kwargs["label"] = label
    kwargs["reactor"] = callback
    f = getframe().f_back
    if "__module__" in f.f_locals and "__qualname__" in f.f_locals:
        # Called within a class body
        obj = Ellipsis # Name and instance autodetect via descriptor protocol
    else:
        obj = f.f_locals.get("self", f.f_locals.get("cls"))
    args = dict(enumerate(args))
    args.update(kwargs)
    if obj is not None:
        return Attribute(obj, Ellipsis, type(Ellipsis), Ellipsis, None, args)
    raise SettingsError("Activator() must be called from within a class or a method")
    